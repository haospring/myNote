# 面向对象的高级引用

## 特征

**继承：**
		也称泛化，子类共享父类的属性和方法的机制
**封装：**
		是将属性和行为（方法）组合成一个独立的系统单位（类）；
		最大的特点是降低了对象之间的耦合性
**多态：**
		同一个命名可以具备不同的功能

## 继承

**概述：**

- java中的继承通过关键字extends继承一个已经存在的类，这个过程在开发中称为继承（泛化）；

  - 被继承的类称为父类（超类、基类），新生成的这个类称为子类（派生类）；
  - 子类可以继承父类的所有属性和方法（非私有）
  - **语法格式：**
    		[访问范围修饰符] class 子类名 extends 父类名{
        	成员；
    }

**说明：**

  - 继承的好处
    - 使编码效率高
    - 易维护
    - 代码复用性
- 继承的注意事项：
  - java中类的继承只能是单继承，每一个java类只具备一个父类，不允许出现类的多重继承（接口例外）；
  - 一个父类可以有多个子类
  - 子类可以继承父类的所有的属性和方法（非私有）
- 继承的使用注意事项（子类实例化时父类的构造方法被执行）：
  - 描述：继承中子类实例化时先实例化其父类，然后实例化子类
  - 子类实例化时，先调用父类的构造方法，父类的构造方法执行完毕才会执行子类的构造方法
- 如何调用父类的构造方法
  - super([参数列表])使用
  - 使用：调用父类的构造方法，由括号内的参数决定调用的是哪一个构造方法
  - 特点：只能出现在子类的构造方法中；只能出现在构造方法的第一行；
  - 特点：如果子类的构造方法中没有出现super关键字，那么编译工具会默认提供一个不带参数的super()；如果父类没有无参构造器，子类会报错；
  - this()调用本类的构造方法，只能出现在构造方法的第一行
  - super()和this()不能同时出现；
- super()和this()的使用与区别
  - super和this使用与区别：
    - super指向父类方法的引用
    - this完成全局属性的引用（本类引用）

### 抽象类和接口

#### 抽象类

##### 方法重写

**方法覆盖（override）与方法重载（overload）：**

- 描述：方法覆盖也可以称为方法重写（rewrite），子类从父类中继承过来的方法可以重写

  - 规则：
      - 相同的方法名；
      - 相同的参数列表；
      - 返回值类型要比父类方法更小或相等
      - 抛出的异常范围小于等于父类
      - 方法的访问权限不小于父类方法的访问权限
- @override是用来标注该方法为重写方法，这种标注形式称为注解
  - super.调用的是父类的方法

**什么是抽象类？**

- 描述：java中使用关键字abstract修饰的类称为抽象类；抽象类是由抽象方法和普通方法所组成的，通常开发中抽象类可以全部都是抽象方法，也可以全部都是普通方法；
- 语法格式：
  - [范围访问修饰符] abstract class 类名{成员;}

**抽象方法定义的语法格式**

- 描述：由abstract关键字定义的方法称为抽象方法，抽象方法只有方法形式，没有具体的方法体；抽象方法必须通过方法重写（方法覆盖）来补全方法体，因此抽象方法不能由private、final、static修饰，但是由static修饰的方法可以被再次声明
- 语法格式：
  - [访问范围修饰符] abstract 返回值类型 方法名([参数列表]);
- 补充说明：
  - final关键字（最终的）：
    - 可以修饰三项内容
    - 修饰属性（全局和局部），代表该属性不能被重新赋值，java不会给它提供默认值；
    - 修饰方法，不能被重写或覆盖
    - 修饰类，不能被继承

#### 接口

- **什么是接口？**
  		java的类只能单继承，一个子类只能具备一个父类，但是一个父类可以具备多个子类；所以java通过接口可以完成多重继承。
- **概念：**
  - 接口中只包含常量和抽象方法（jdk8之后可以具备非抽象方法），意味着没有变量和普通方法；
    - 接口对于类来说是一套规范；
    - 接口不是类，不能直接实例化
- **语法格式：**
  - [范围访问修饰符] interface 接口名{接口的成员;}
  - 接口的成员：常量、抽象方法（jdk8之后具备默认和静态的方法）
- **类和接口的关系**
  - 描述：类是用来实现接口的（implements）；
  - 如果开发者想要使用接口必须定义一个java类来实现这个接口；
    - 实现接口必须实现接口中所有的抽象方法（重写）；
    - 多个无关的类可以实现同一个接口，一个类也可以实现多个接口
    - 一个类可以继承一个父类（单继承），但是一个类在继承一个父类的同时，却可以实现多个接口

#### 总结

- 接口和抽象类
  - 抽象类：抽象类不能直接实例化，只能通过子类完成实例化过程；抽象方法不能为static的；
  - 接口：接口不能直接实例化，需要通过实现类实例化；抽象方法不能由static修饰；如果一个普通类实现接口（该类不是抽象类），必须重写接口中的抽象方法；接口可以多重继承；接口只能定义静态的最终的常量和抽象的方法（jdk8及之后例外）；

#### jdk8之后的接口特性

- 描述：
  - jdk8版本之前，接口中只能出现静态的、final的常量和抽象方法；jdk8之后添加了新的接口功能
  - 默认的方法定义：
    - 语法格式：
      [访问范围修饰符] interface 接口名{
      	default 返回值类型 方法名([参数列表]){
      		方法体;
      	}

     	[访问范围修饰符] static 返回值类型 方法名([参数列表]){
				方法体;
				}
    	 }
    	
    	

